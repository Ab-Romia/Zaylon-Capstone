"""
Analytics tracking and dashboard service.
"""
import logging
from datetime import datetime, timedelta
from typing import Dict, Any, List, Optional, Union

from sqlalchemy import select, func, and_
from sqlalchemy.ext.asyncio import AsyncSession

from database import AnalyticsEvent, Conversation
from models import (
    AnalyticsLogResponse, AnalyticsDashboardResponse,
    TopIntent, TopProduct
)
from core.constants import (
    AI_COST_PER_1K_INPUT, AI_COST_PER_1K_OUTPUT,
    AI_INPUT_TOKEN_RATIO, AI_OUTPUT_TOKEN_RATIO
)
from core.enums import EventType

logger = logging.getLogger(__name__)


async def log_event(
    db: AsyncSession,
    customer_id: str,
    event_type: Union[str, EventType],
    event_data: Dict[str, Any],
    response_time_ms: Optional[int] = None,
    ai_tokens_used: Optional[int] = None
) -> AnalyticsLogResponse:
    """
    Log an analytics event.

    Event types:
    - message_received: New message received
    - intent_classified: Intent was classified
    - cache_hit: Response served from cache
    - cache_miss: Response generated by AI
    - order_created: Order was created
    - product_searched: Product search performed
    - context_retrieved: Conversation context retrieved
    """
    # Convert enum to string if needed
    event_type_str = event_type.value if isinstance(event_type, EventType) else event_type
    logger.info(f"Logging event: {event_type_str} for {customer_id}")

    event = AnalyticsEvent(
        customer_id=customer_id,
        event_type=event_type_str,
        event_data=event_data,
        response_time_ms=response_time_ms,
        ai_tokens_used=ai_tokens_used
    )

    db.add(event)
    await db.commit()

    return AnalyticsLogResponse(success=True)


async def get_dashboard(
    db: AsyncSession,
    start_date: Optional[datetime] = None,
    end_date: Optional[datetime] = None
) -> AnalyticsDashboardResponse:
    """
    Get analytics dashboard with key metrics.
    """
    # Default to last 30 days if no dates provided
    if not end_date:
        end_date = datetime.utcnow()
    if not start_date:
        start_date = end_date - timedelta(days=30)

    logger.info(f"Generating dashboard for {start_date} to {end_date}")

    # Total messages
    total_messages = await get_total_messages(db, start_date, end_date)

    # Total orders
    total_orders = await get_total_orders(db, start_date, end_date)

    # Conversion rate
    conversion_rate = (total_orders / total_messages * 100) if total_messages > 0 else 0.0

    # Average response time
    avg_response_time = await get_avg_response_time(db, start_date, end_date)

    # Messages by channel
    messages_by_channel = await get_messages_by_channel(db, start_date, end_date)

    # Top intents
    top_intents = await get_top_intents(db, start_date, end_date)

    # Top products inquired
    top_products = await get_top_products(db, start_date, end_date)

    # AI cost estimate
    ai_cost = await estimate_ai_cost(db, start_date, end_date)

    # Cache hit rate
    cache_hit_rate = await get_cache_hit_rate(db, start_date, end_date)

    return AnalyticsDashboardResponse(
        total_messages=total_messages,
        total_orders=total_orders,
        conversion_rate=round(conversion_rate, 2),
        avg_response_time_ms=round(avg_response_time, 2),
        messages_by_channel=messages_by_channel,
        top_intents=top_intents,
        top_products_inquired=top_products,
        ai_cost_estimate=round(ai_cost, 4),
        cache_hit_rate=round(cache_hit_rate, 2)
    )


async def get_total_messages(
    db: AsyncSession,
    start_date: datetime,
    end_date: datetime
) -> int:
    """Get total number of incoming messages."""
    stmt = (
        select(func.count())
        .select_from(Conversation)
        .where(
            and_(
                Conversation.direction == "incoming",
                Conversation.created_at >= start_date,
                Conversation.created_at <= end_date
            )
        )
    )
    result = await db.execute(stmt)
    return result.scalar() or 0


async def get_total_orders(
    db: AsyncSession,
    start_date: datetime,
    end_date: datetime
) -> int:
    """Get total number of orders created."""
    stmt = (
        select(func.count())
        .select_from(AnalyticsEvent)
        .where(
            and_(
                AnalyticsEvent.event_type == "order_created",
                AnalyticsEvent.created_at >= start_date,
                AnalyticsEvent.created_at <= end_date
            )
        )
    )
    result = await db.execute(stmt)
    return result.scalar() or 0


async def get_avg_response_time(
    db: AsyncSession,
    start_date: datetime,
    end_date: datetime
) -> float:
    """Get average response time in milliseconds."""
    stmt = (
        select(func.avg(AnalyticsEvent.response_time_ms))
        .where(
            and_(
                AnalyticsEvent.response_time_ms.isnot(None),
                AnalyticsEvent.created_at >= start_date,
                AnalyticsEvent.created_at <= end_date
            )
        )
    )
    result = await db.execute(stmt)
    return float(result.scalar() or 0.0)


async def get_messages_by_channel(
    db: AsyncSession,
    start_date: datetime,
    end_date: datetime
) -> Dict[str, int]:
    """Get message count by channel."""
    stmt = (
        select(Conversation.channel, func.count().label("count"))
        .where(
            and_(
                Conversation.direction == "incoming",
                Conversation.created_at >= start_date,
                Conversation.created_at <= end_date
            )
        )
        .group_by(Conversation.channel)
    )
    result = await db.execute(stmt)
    rows = result.all()

    channels = {"instagram": 0, "whatsapp": 0}
    for row in rows:
        if row.channel in channels:
            channels[row.channel] = row.count

    return channels


async def get_top_intents(
    db: AsyncSession,
    start_date: datetime,
    end_date: datetime,
    limit: int = 10
) -> List[TopIntent]:
    """Get top intents by frequency."""
    stmt = (
        select(Conversation.intent, func.count().label("count"))
        .where(
            and_(
                Conversation.intent.isnot(None),
                Conversation.direction == "incoming",
                Conversation.created_at >= start_date,
                Conversation.created_at <= end_date
            )
        )
        .group_by(Conversation.intent)
        .order_by(func.count().desc())
        .limit(limit)
    )
    result = await db.execute(stmt)
    rows = result.all()

    # Calculate total for percentages
    total = sum(row.count for row in rows)

    return [
        TopIntent(
            intent=row.intent,
            count=row.count,
            percentage=round((row.count / total * 100) if total > 0 else 0, 2)
        )
        for row in rows
    ]


async def get_top_products(
    db: AsyncSession,
    start_date: datetime,
    end_date: datetime,
    limit: int = 10
) -> List[TopProduct]:
    """Get top products inquired about."""
    stmt = (
        select(AnalyticsEvent.event_data, func.count().label("count"))
        .where(
            and_(
                AnalyticsEvent.event_type == "product_searched",
                AnalyticsEvent.created_at >= start_date,
                AnalyticsEvent.created_at <= end_date
            )
        )
        .group_by(AnalyticsEvent.event_data)
        .order_by(func.count().desc())
        .limit(limit)
    )
    result = await db.execute(stmt)
    rows = result.all()

    top_products = []
    for row in rows:
        if isinstance(row.event_data, dict):
            product_name = row.event_data.get("query", "Unknown")
            top_products.append(TopProduct(product=product_name, count=row.count))

    return top_products


async def estimate_ai_cost(
    db: AsyncSession,
    start_date: datetime,
    end_date: datetime
) -> float:
    """Estimate AI API cost based on tokens used."""
    stmt = (
        select(func.sum(AnalyticsEvent.ai_tokens_used))
        .where(
            and_(
                AnalyticsEvent.ai_tokens_used.isnot(None),
                AnalyticsEvent.created_at >= start_date,
                AnalyticsEvent.created_at <= end_date
            )
        )
    )
    result = await db.execute(stmt)
    total_tokens = result.scalar() or 0

    # Estimate cost based on token ratios
    input_tokens = total_tokens * AI_INPUT_TOKEN_RATIO
    output_tokens = total_tokens * AI_OUTPUT_TOKEN_RATIO

    cost = (
        (input_tokens / 1000) * AI_COST_PER_1K_INPUT +
        (output_tokens / 1000) * AI_COST_PER_1K_OUTPUT
    )

    return cost


async def get_cache_hit_rate(
    db: AsyncSession,
    start_date: datetime,
    end_date: datetime
) -> float:
    """Calculate cache hit rate."""
    # Get cache hits
    stmt_hits = (
        select(func.count())
        .select_from(AnalyticsEvent)
        .where(
            and_(
                AnalyticsEvent.event_type == "cache_hit",
                AnalyticsEvent.created_at >= start_date,
                AnalyticsEvent.created_at <= end_date
            )
        )
    )
    result = await db.execute(stmt_hits)
    hits = result.scalar() or 0

    # Get cache misses
    stmt_misses = (
        select(func.count())
        .select_from(AnalyticsEvent)
        .where(
            and_(
                AnalyticsEvent.event_type == "cache_miss",
                AnalyticsEvent.created_at >= start_date,
                AnalyticsEvent.created_at <= end_date
            )
        )
    )
    result = await db.execute(stmt_misses)
    misses = result.scalar() or 0

    total = hits + misses
    if total == 0:
        return 0.0

    return (hits / total) * 100
